# Mysql基础

## 1、数据库相关概率

| 名称           | 全程                                                         | 简称                             |
| :------------- | :----------------------------------------------------------- | :------------------------------- |
| 数据库         | 存储数据的仓库，数据是有组织的进行存储                       | DataBase(DB)                     |
| 数据库管理系统 | 操纵和管理数据库的大型软件                                   | DataBase Management System(DBMS) |
| SQL            | 操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准 | Structured Query language(SQL)   |

用户通过SQL操控来操作数据库管理系统来操作数据库以及数据库中的数据， 所以用户不能之间操控数据库。

![image-20250904103100538](/home/zhang/.config/Typora/typora-user-images/image-20250904103100538.png)

### MySQL数据库

- 关系型数据库（RDBMS）
  - 概率：建立在关系模型基础上，由多张互相连接的二维表组成的数据库。它使用**表格（Table）**来存储数据，其中每一行代表一条记录，每一列代表一个字段。
  - 特点：
    - 使用表存储数据
    - 使用SQL语句操作



## 2、SQl

#### 1、SQL的概述

Structure Query Language(结构化查询语言)简称SQL，它被美国国家标准局(ANSI)确定为关系型数据库语言的美国标准，后被国际化标准组织(ISO)采纳为关系数据库语言的国际标准。数据库管理系统可以通过SQL管理数据库；定义和操作数据，维护数据的完整性和安全性。

#### 2、SQL的优点

1、简单易学，具有很强的操作性
2、绝大多数重要的数据库管理系统均支持SQL
3、高度非过程化；用SQL操作数据库时大部分的工作由DBMS自动完成

#### 3、SQL的分类

1、DDL(Data Definition Language) 数据定义语言，用来操作数据库、表、列等； 常用语句：CREATE、 ALTER、DROP
2、DML(Data Manipulation Language) 数据操作语言，用来操作数据库中表里的数据；常用语句：INSERT、 UPDATE、 DELETE
3、DCL(Data Control Language) 数据控制语言，用来操作访问权限和安全级别； 常用语句：GRANT、DENY
4、DQL(Data Query Language) 数据查询语言，用来查询数据 常用语句：SELECT

#### 4、DDL语句详解

##### 1、DDL-数据库操作

- 查询

  - 查询所有数据库

    ```sql
    SHOW DATABASES;
    ```

  - 查询当前数据库

    ```sql
    SELECT DATABASE();
    ```

- 创建

  ```sql
  CREATE DATABASE [IF NOT EXISTS] 数据库名称 [DEFAULT CHARSET 字符集] [COLLATE 排序规制];
  ```

- 删除

  ```sql
  DROP DATABASE [IF NOT EXISTS] 数据库名称；
  ```

- 使用

  ```sql
  USE 数据库名；
  ```

  

##### 2、DDL-表操作-查询

> 注意：所有的DDL表操作语句，都必须使用DML语句中的USE语句使用数据库。只用处于数据库中时才能使用表操作；

- 查询当前数据库中的所有表

  ```sql
  SHOW TABLES;
  ```

- 查询表结构

  ```sql
  DESC 表名;
  ```

- 查询指定表的建表语句

  ```sql
  SHOW CREATE TABLE 表名；
  ```

  

##### 3、DDL-表操作-创建

```sql
CREATE TABLE 表名(
    字段1 字段1类型[COMMENT 字段1注释],
    字段2 字段2类型[COMMENT 字段2注释],
    字段3 字段3类型[COMMENT 字段3注释],
    字段4 字段4类型[COMMENT 字段4注释]
)[COMMENT 表注释];
```

**注意**：[...]为可选操作，**最后一个字段没有逗号**，带了逗号会报错。



##### 4、DDL-表操作-数据类型

使用MySQL数据库存储数据时，不同的数据类型决定了 MySQL存储数据方式的不同。为此，MySQL数据库提供了多种数据类型，其中包括整数类型、浮点数类型、定点 数类型、日期和时间类型、字符串类型、二进制…等等数据类型。

| 类型分类          | 数据类型              | 描述         | 存储空间        | 示例与备注                                                   |
| ----------------- | --------------------- | ------------ | --------------- | ------------------------------------------------------------ |
| **整数类型**      | `TINYINT`             | 极小整数     | 1 字节          | 存储年龄（`TINYINT UNSIGNED`），范围 0-255                   |
|                   | `SMALLINT`            | 小整数       | 2 字节          | 存储年级或班级数                                             |
|                   | `MEDIUMINT`           | 中等整数     | 3 字节          | 通常用于比 `SMALLINT` 大但比 `INT` 小的场景                  |
|                   | `INT`                 | 标准整数     | 4 字节          | 最常用，如用户 ID、订单号                                    |
|                   | `BIGINT`              | 大整数       | 8 字节          | 用于存储需要超过 `INT` 范围的数值，如 Twitter 的用户 ID      |
| **浮点数类型**    | `FLOAT(M,D)`          | 单精度浮点数 | 4 字节          | 有精度损失，不推荐用于精确计算                               |
|                   | `DOUBLE(M,D)`         | 双精度浮点数 | 8 字节          | 比 `FLOAT` 精度高，但仍有精度问题                            |
| **定点数类型**    | `DECIMAL(M,D)`        | 精确数值类型 | 变长            | 用于货币、价格、利率等需要精确计算的场景                     |
| **字符串类型**    | `CHAR(M)`             | 定长字符串   | M 字节          | 存取速度快，长度固定，如手机号、邮政编码、MD5 值。M 最大 255 |
|                   | `VARCHAR(M)`          | 变长字符串   | L+1 或 L+2 字节 | 最常用，只占用实际存储的字符数，如用户名、地址。M 最大 65535 |
|                   | `TINYTEXT`            | 短文本       | 最长 255 字符   | 存储短文本，如一句话简介                                     |
|                   | `TEXT`                | 标准文本     | 最长 65535 字符 | 存储大段文本，如文章正文                                     |
|                   | `MEDIUMTEXT`          | 中等文本     | 最长 16MB       | 适用于存储较长的文章或文档                                   |
|                   | `LONGTEXT`            | 长文本       | 最长 4GB        | 存储极长的文本内容                                           |
|                   | `ENUM('v1','v2',...)` | 枚举类型     | 1 或 2 字节     | 从预定义值中选择一个，如性别 ('男', '女')                    |
|                   | `SET('v1','v2',...)`  | 集合类型     | 变长            | 可以选择一个或多个值，如爱好 ('阅读, 运动')                  |
| **日期/时间类型** | `DATE`                | 日期         | 3 字节          | 格式 'YYYY-MM-DD'，如 '2025-07-05'                           |
|                   | `TIME`                | 时间         | 3 字节          | 格式 'HH:MM:SS'，如 '10:52:56'                               |
|                   | `DATETIME`            | 日期和时间   | 8 字节          | 格式 'YYYY-MM-DD HH:MM:SS'，不受时区影响                     |
|                   | `TIMESTAMP`           | 时间戳       | 4 字节          | 格式与 `DATETIME` 相同，但值会随时间自动更新，并受时区影响   |

##### 5、DDL-表操作-修改

- 添加字段

  ```sql
  ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];
  ```

  > 案例：
  >
  > 为emp表添加一个新的字段“昵称”为nickname
  >
  > ```sql
  > ALTER TABLE `emp` add nickname varchar(20) comment `昵称`;
  > ```

- 修改字段名和字段类型

  ```sql
  ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度)  [COMMENT 注释] [约束];;
  ```

  > 案例：
  >
  > 将emp表中的nickname字段修改成username，类型为varchar(30);
  >
  > ```sql
  > ALTER TABLE `emp` CHANGE nickname username VARCHAR(30) COMMENT '昵称';
  > ```

- 删除字段

  ```sql
  ALTER TABLE 表名 DROP 字段;
  ```

  > 案例：
  >
  > 将emp表中的nickname字段删除
  >
  > ```sql
  > ALTER `emp` DROP nickname;
  > ```

- 修改表名

  ```sql
  ALTER TABLE 表名 RENAME TO 新表名；
  ```

- 删除表

  - DROP TABLE [if not exists] 表名；
  - truncated table 表名；



## 3、事务

事务是一系列操作（通常是数据库操作）的集合，这些操作被视为一个不可分割的整体。一个事务中的所有操作要么全部成功执行，

#### 事务的 ACID 特性

为了保证数据库事务的正确性，数据库系统必须满足四个关键特性，通常被称为 **ACID 特性**：

- 原子性（Atomicity）

**原子性**是指一个事务是一个不可分割的最小工作单元。事务中的所有操作，要么都成功，要么都失败回滚到事务开始前的状态。如果任何一个操作失败，那么整个事务都会被撤销。

- 一致性（Consistency）

**一致性**是指事务执行前后，数据库从一个一致性状态转换到另一个一致性状态。这意味着数据库的完整性约束（如主键唯一、外键引用等）在事务开始和结束时都必须保持有效。在上面的转账例子中，一致性保证了总金额在转账前后是不变的。

- 隔离性（Isolation）

**隔离性**是指多个事务并发执行时，一个事务的执行不会被其他事务干扰。这意味着一个事务的中间状态对其他事务是不可见的。数据库系统提供了不同的隔离级别来控制这种可见性，以平衡性能和数据一致性。

- 持久性（Durability）

**持久性**是指一个事务一旦提交，它对数据库的改变就是永久性的，即使系统发生故障（如断电），数据也不会丢失。



#### 并发事务问题：

| 问题 | 描述                                   |
| ---- | -------------------------------------- |
| 脏读 | 一个事务读到另一个事务还没有提交的数据 |
| 不可重复度| 一个事务先后读取同一条记录，但是两次读取的结果不同，称之为不可重复读|
|幻读| 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在了，好像出现了“幻影”。|

- 脏读：

一个事务A，在数据库中，事务A首先进行了一条查询操作，查询Id为1的数据，之后进行了一次更新操作，更新Id为1的数据。此时还没有提交事务，有一个事务B开始了查询操作，查询Id为1的数据，结果查询到了事务A执行更新操作之后的数据，明明事务A没有提交事务，结果事务B却读取到了更新后的数据，这种一个事务读取到另一个事务没有提交的数据就称为脏读。

- 不可重复度

事务A在执行查询Id为1的数据，查询到了一个结果。这时，另一个事务B执行了一个更新操作，更新了Id为1的数据，并提交了事务，此时事务A又进行了一次查询Id为1的操作，查询的结果与第一次查询的结果不同。这种情况，一个事务先后读取同一条记录，但是两次读取的结果不同，称之为不可重复读

- 幻读：

一个事务A在查询数据库时，没有查找到Id为1的数据，没有提交事务。在此时，有另一个事务B，它插入了一条Id为1的数据并进行了提交。由于事务A没有查询到Id为1的数据，此时事务A想要插入一条Id为1的数据，这个时候就会出现主键重复的问题。所以事务A在执行这个插入操作时就会报错，此时事务A再去查询Id为1的数据，结果还是没有，但是进行插入Id为1的数据时，又会出现主键重复错误。这种情况就好像出现了幻觉一样，因此把这个现象称之为“幻读”。



#### 事务的隔离级别

MySQL 提供了四种标准的隔离级别，从低到高依次是：

- **读未提交 (Read Uncommitted)**
- **读已提交 (Read Committed)**
- **可重复读 (Repeatable Read)**
- **串行化 (Serializable)**

------



##### 1. 读未提交 (Read Uncommitted)



这是最低的隔离级别。

- **特点**: 一个事务可以读到另一个未提交事务的修改。
- **会出现的问题**:
  - **脏读 (Dirty Read)**：这是此级别最主要的问题。如果一个事务读到了另一个未提交的修改，而后者又回滚了，那么第一个事务读到的就是“脏数据”。
  - **不可重复读 (Non-repeatable Read)**
  - **幻读 (Phantom Read)**
- **应用场景**: 极少使用，只有在对数据一致性要求极低，而对并发性能要求极高的特定场景下才会考虑。

------



##### 2. 读已提交 (Read Committed)



这是大多数数据库（如 SQL Server、Oracle）的默认隔离级别。

- **特点**: 一个事务只能读到其他**已提交**事务的修改。
- **解决了什么问题**: **脏读**。因为只读取已提交的数据，所以不会出现读取到回滚数据的情况。
- **会出现的问题**:
  - **不可重复读 (Non-repeatable Read)**：在同一个事务内，两次读取同一行数据，结果可能不同。因为在两次读取之间，另一个事务可能已经提交了对该行的修改。
  - **幻读 (Phantom Read)**
- **应用场景**: 在保证了一定数据一致性的同时，提供了较高的并发性能，是许多互联网应用的首选。

------



##### 3. 可重复读 (Repeatable Read)



这是 **MySQL InnoDB 引擎的默认隔离级别**。

- **特点**: 在同一个事务内，多次读取同一行数据，结果总是相同的，无论其他事务是否提交了修改。
- **解决了什么问题**: **脏读** 和 **不可重复读**。
- **会出现的问题**: **幻读**。虽然解决了同一行数据的重复读问题，但无法阻止另一个事务在范围查询中**插入新行**，导致再次查询时出现“幽灵”数据。不过，**MySQL 的 InnoDB 引擎**通过名为 **Next-Key Lock** 的机制，解决了幻读问题，使其在 **Repeatable Read** 级别下也能避免幻读。
- **应用场景**: MySQL 的默认设置，在性能和数据一致性之间找到了很好的平衡点，适用于绝大多数业务场景。

------



##### 4. 串行化 (Serializable)



这是最高的隔离级别。

- **特点**: 强制事务串行执行，避免了并发冲突。
- **解决了什么问题**: **所有并发读写问题**，包括脏读、不可重复读和幻读。
- **会出现的问题**: **性能极差**。因为所有事务都需要排队执行，并发能力几乎为零。
- **应用场景**: 极少使用，只用于对数据一致性有最高要求，且对并发性能要求不高的特殊场景，比如需要进行非常严格的数据一致性校验。



| 隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| :----------------------- | :--- | :--------- | :--- |
| Read Uncommitted         | ✅    | ✅          | ✅    |
| Read Committed           | ❌    | ✅          | ✅    |
| Repeatable Read(Default) | ❌    | ❌          | ✅    |
| Serializable             | ❌    | ❌          | ❌    |

插卡事务的隔离级别

SELECT @@TRANSACTION_ISOLATION;

设置事务隔离级别

SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVER {READ Uncommitted | Read Committed | Repeatable Read | Serializable};



# MySQL高级

## 1、存储引擎

### MySQL体系结构图

![一文搞懂MySQL体系架构！！ - 冰河团队- 博客园](https://img-blog.csdnimg.cn/20210303232240506.png)

层级结构：

1. 连接层
   - 主要完成一些类似与连接处理、授权认证、及相关的安全方案。
2. 服务层
   - 完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化等等。
3. 引擎层（索引是在引擎层实现的，所以不同的引擎有不同的索引）
4. 存储层（数据库的数据，基本上都是存储到磁盘中的）



### 存储引擎简介

#### 什么是存储引擎？

存储引擎是 MySQL 的核心组件，它负责管理和处理数据库中的数据。你可以把它看作是数据库管理系统（DBMS）中，位于文件系统之上的一层“数据管家”。

具体来说，存储引擎决定了数据如何被：

- **存储**到磁盘上。
- **读取**和**更新**。
- **组织**和**索引**。
- **处理**并发操作和事务。

> - ***引擎是没有好坏之分的，不同的业务使用不同的存储引擎。***
>
> - ***存储引擎是基于表的，而不是基于库的，所以存储引擎也可以被称之为表类型***

![image-20250904140452385](/home/zhang/.config/Typora/typora-user-images/image-20250904140452385.png)

**Mysql的默认存储引擎是InnoDB， InnoDB支持事务、行级锁、外键。**



#### 存储引擎的特点

##### InnoDB

- 介绍
  - InnoDB是一种兼顾高可靠和高性能的通用存储引擎
- 特点
  - DML操作支持ACID（原则性、一致性性、隔离性、持久性）模型，支持事务；
  - 行级锁，提高并发访问性能
  - 支持外键（FOREIGN KEY）约束，保证数据的完整性和正确性

- 文件
  - xxx.ibd:xxx代表的是表名，innoDB引擎的没张表都会对应这样的一个表空间文件，存储该表的表结构（frm、sdi）、数据、索引。
  - 参数：innodb_file_per_table



###### innoDB的逻辑存储结构

![mysql innodb引擎逻辑存储结构--黑马程序员笔记-CSDN博客](https://i-blog.csdnimg.cn/blog_migrate/d87d72ab2ef2e453bd47c8cad3fe20f4.png)

一个区的大小是固定的：1M

一个页的大小也是固定的：16K

所以一个区有64个页（16K * 64 = 1024k = 1M）



##### MyISAM

- 简介

  - 是一个非事务性的存储引擎，以其简单的结构和高读写速度而著称。

- 特点

  - **事务支持**: **不支持事务**，如果一个操作失败，无法回滚，可能导致数据不一致。

  - **表级锁**: 使用 **表级锁**，这意味着任何对表的修改操作都会锁定整个表。在高并发写入场景下，会严重降低性能。

  - **外键约束**: **不支持外键**，需要通过应用程序来保证数据的完整性。

  - **崩溃恢复**: 没有崩溃恢复能力，如果数据库意外关闭，可能会导致数据文件损坏，需要手动修复。

  - **索引**: 使用 **非聚集索引**。数据和索引是分开存储的，查找数据需要两次寻址。



##### Memory

- 简介
  - Memory引擎的表数据是存储在内存中的，内存是不支持持久化的，断电即失，所以Memory引擎只能作为临时表或缓存使用。
- 特点
  - 数据存储在内存中
  - Hash索引（默认）
  - 读取速度快
- 文件
  - xxx.sdi：存储表结构信息



### 存储引擎的选择

在选择存储引擎时，应该根据系统的特点选择合适的引擎

- InnoDB： 使用于对事务的完整性有比较高的要求
- MyISAM：以读取和插入操作为主，只有很少的更新和删除操作（基本上被Mongodb取代）
- Memory：访问速度快，通常用于临时表和缓存。（被redis取代）





## 2、索引

### 索引概述

- 索引
  - 索引（index）是数据库中一种重要的**数据结构**，可以帮助我们**快速查找数据**。

> 如果没有index，在查询数据时，要进行**全局扫描**，**全局扫描**是很耗时的。

- 优缺点
  - 优势
    - 提高数据检索的效率，降低数据库的IO成本高
    - 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗
  - 缺点
    - 索引是要占存储空间的
    - 索引提高了数据的查询效果，但是在进行更新操作时，由于需要额外更新索引，所以降低了更新的效率。

### 索引结构

Mysql的索引是在存储引擎上实现的，所以不同的存储引擎具有不同的索引结构，主要包含一下几种

| **索引结构**          | **描述**                                                     |
| --------------------- | ------------------------------------------------------------ |
| **B+Tree索引**        | **最常见的索引类型，大部分引擎都支持B+Tree索引**             |
| Hash索引              | 底层数据结构是用Hash表实现的                                 |
| R-Tree（空间索引）    | R-Tree（空间索引）是MyISAM引擎的一个特殊索引类型，主要用于地理空间的数据类型 |
| Full-text（）全文索引 | 是一种通过建倒排索引，快速匹配文档的方式                     |

|       **索引**        |   **InnoDb**    | **MyISAM** | **Memory** |
| :-------------------: | :-------------: | :--------: | :--------: |
|      B+Tree索引       |      支持       |    支持    |    支持    |
|       Hash索引        |     不支持      |   不支持   |    支持    |
|  R-Tree（空间索引）   |     不支持      |    支持    |   不支持   |
| Full-text（）全文索引 | 5.6版本之和支持 |    支持    |   不支持   |

#### B+Tree





#### 索引分类

| 分类     | 含义                                                 | 特点                   | 关键字    |
| -------- | ---------------------------------------------------- | ---------------------- | --------- |
| 主键索引 | 针对主键的索引                                       | 默认创建，只可以有一个 | PRIMARY   |
| 唯一索引 | 避免同一个表中某些数据列中的值重复                   | 可以有多个             | UNIQUE    |
| 常规索引 | 快速定位特定数据                                     | 可以有多个             |           |
| 全文索引 | 全文索引查找的是文本中的关键字，而不是比较索引中的值 | 可以有多个             | FULL TEXT |

在innodb引擎中，根据索引的存储形式，又可以分为一下两类：

| 分类                        | 含义                                                       | 特点                 |
| --------------------------- | ---------------------------------------------------------- | -------------------- |
| 聚集索引（Clustered index） | 将数据存储与索引放在了一块，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个 |
| 二级索引（Secondary index） | 将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个         |

- 聚集索引：
  - 默认主键索引就是`聚集索引`。
  - 如果没有主键，将使用第一个`unique`索引作为聚集索引。
  - 如果表没有主键，也没有`unique`索引，则innoDB会自动生成一个`rowid`作为隐藏的聚集索引
  - 也就是说，在innoDB引擎中，必须有且只有一个聚集索引
  - 聚集索引的叶子节点下面挂载的都是行数据
- 二级索引：
  - 叶子节点保存的主键id，因此对二级索引进行查询时，需要两次查询，称为`回表查询`。第一次在二级索引中查找出目标的主键，然后去聚集索引中查询行数据。