# Java八股文

## Mysql篇

### 1、如何定位慢查询？

慢查询是值在执行sql中，响应时间超过指定阈值的的SQL查询语句。这种查询显著消耗数据库资源，导致系统性能下降，影响用户体验，所以要避免慢查询。

我们当时在进行接口测试时，发现了一个响应时间很慢的接口，压测的结果大概是5秒钟。我们的系统当时采用了运维工具，运维人员发现是SQL导致的响应速度慢。在调试阶段，我们已经开启了Mysql的慢查询日志，我们设置的阈值是2秒钟，一旦sql的执行时间超过了2秒钟，mysql就会把这条sql语句保存到慢查询日志中，通过查看慢查询日志，就能找到是哪条sql语句导致的，我们就能去优化这条sql语句。



### 2、 那么这个SQL语句执行很慢，如何进行分析呢？

导致慢查询的原因大概率是这个四种：

- 聚合查询
- 多表查询
- 表数据量过大查询
- 深度分页查询

如果是聚合查询引起的，可以采用临时表来解决。多表查询可以去尝试优化sql语句。表数据量过大查询，添加索引去解决。

可以通过SQL执行计划去查询慢查询的原因，在mysql中使用EXPIAIN或者DESC命令可以获取MySQL执行SELECT语句的信息，具体使用就是在select语句之前加上关键字explain/desc;

- 主要关注: possible_key: 当前sql可能会使用到的索引
- key:当前sql实际命中的索引
- key_len：索引占用的大小
- Extra：额外的优化建议
- type:这条sql的连接类型，性能由好到差为NULL、system、const、eq_ref、range、index、all
  - system: 查询系统中的表
  - const：根据主键查询
  - eq_ref：主键索引查询或者唯一索引查询
  - ref：使用的是索引查询，
  - range：sql查询走的是索引，执行的是范围查询
  - index：这条sql语句走的全索引查询，遍历整个索引树，效率不高
  - all：全盘扫描

在实际开发中，连接类型必须在range及以上，如果是index、all则必须进行优化。



> 如何分析？
>
> 可以通过Mysql自带的分析工具EXPLAIN
>
> - 通过key和key_len字段，检测是否命中了索引
> - 通过type字段，查看sql是否有进一步的优化空间。判断是否存在全索引扫描和全盘扫描
> - 通过extra字段，判断是否出现了回表查询，如果出现了回表查询，可以根据业务所需的字段，创建一个**复合索引**，包含查询所需的所有列。

### 3、什么是索引？（了解过索引吗？）

>什么是索引？
>
>- 索引是帮助MySQL高效查询数据的一种结构（有序）
>
>- 索引可以提高数据检索的效率，降低数据库的IO成本（不需要全表扫描）
>
>- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗
>
>  
>
>索引的底层数据结构了解过吗？
>
>MySQL的默认引擎InnoDB采用的是B+Tree的数据结构来存储索引
>
>- B+Tree的阶数更多，路径更短。
>- 磁盘读写代价B+Tree更低，非叶子节点只存指针，叶子节点保存数据。
>- B+Tree的叶子节点是一个双向链表，数便于扫库和区间查询。

![image-20250904200037701](/home/zhang/.config/Typora/typora-user-images/image-20250904200037701.png)

### 4、什么是聚簇索引什么是非聚簇索引？

非聚簇索引就是二级索引

| 分类                        | 含义                                                         | 特点                     |
| --------------------------- | ------------------------------------------------------------ | ------------------------ |
| 聚簇索引（Clustered index） | 将数据和索引放在了一块进行存储，索引结构的叶子节点保存的是行数据 | 必须有，而且只有一个     |
| 二级索引（Secondary index） | 将数据和索引分开存储，索引结构的叶子节点保存的对应的主键     | 可以存在多个，也可以没有 |

聚集索引选取规制：

- 如果存在主键，主键就是聚簇索引
- 如果不存在主键，将使用一个unique索引当作聚簇索引
- 如果主键和unique索引都没有，InnoDB引擎回自动生成一个rowid索引当作聚簇索引



回表查询只会发送在二级索引中，它的意思是在二级索引中，它根据二级索引在B+Tree的叶子节点中找到了自己的主键id，然后通过这个主键id再去聚簇索引中查询行数据，因为发送了两次查询索引，因此称为回表查询。

为了避免回表查询，可以使用**索引覆盖**来解决这个问题，什么是索引覆盖呢？简单来说，就是把业务需要的字段，生成一个**复合索引**，这时候，二级索引的叶子节点保存的数据这个复合索引的所有字段，就避免了回表查询。

二级索引（或称非聚集索引）的叶子节点，挂载的数据并不是完整的行数据，而是**索引列的值**和**对应的主键值**。

### 5、什么是覆盖索引？

**覆盖索引**是值查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。

- 使用主键查询时，直接走的是聚簇索引查询，一次索引扫描，直接返回数据，性能高。
- 如果返回的列中没有创建索引，有可能会触发回表查询，因此避免使用select *语句；



### 6、MySQL超大分页怎么处理？

可以使用覆盖索引来解决

在数据量比较大时，如果进行limit分页查询，在查询是，越往后，分页查询的效率就越低。因为分页查询需要对数据进行排序，效率低。

为什么超大分页查询性能低？

- 假设在一个有1000000条数据的表中进行查询时，执行limit 900000，10；此时需要MySQL排序前900010记录，然后它有仅仅需要900000-900010条记录，其他的记录直接丢弃，所以查询的代价非常大。

优化思路：

- 一般分页查询时，通过创建**覆盖索引**能够比较好的提高性能，可以通过**覆盖索引**加**字查询**形式进行优化



### 7、索引创建原则有哪些？

1. 针对数据量较大时，且查询比较繁琐的表建立索引。（一般是单表超过10万条数据）
2. 针对与常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4. 如歌是字符串类型的字段，字段的长度较长，可以针对与字段的特点，建立前罪索引。
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是越多越好，索引越多，维护索引结构的代价也就越大，回影响增删该的效率
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。



### 8、什么时候索引会失效？

1. 违反了最左前缀法则

   如歌索引了多列，要遵循最左前缀法则。值的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，左索引。

   > 在复合索引中，要遵循最左前缀法则。最左前缀法则指的是，在联合索引中，如果你想利用索引进行查询，查询条件必须从索引的**最左边**的列开始，并且是**连续的**。
   >
   > 如果你创建了一个联合索引（name, age, email）,在你使用索引进行查询时，使用select * from student where age=18;时，没有使用联合索引的最左的nama索引，那么这次查询就不会走索引，而是全表扫描。如果是select * from student name="zhangsan" and email="123@gmail.com"；使用了最左前缀的索引，但是跳过了age，那么，这条sql语句它**会**走索引，但只会走到**`name` 这一层**，之后的 `age` 和 `email` 索引都无法被有效利用。这会导致在找到 `name` 对应的记录后，需要进行回表操作，性能不如完美命中索引的情况。
   

2. 不要在索引列上进行运算操作，索引将失效。
3. 字符串不加引号，造成索引失效。其原因是，在查询时，没有对字符串加单引号，MySQL的查询优化器，回自动的进行类型转换，造成索引失效。
4. 使用like的模糊查询有可能造成索引失效。当使用头部模糊匹配时，索引失效。如果仅仅是尾部模糊匹配，索引不会失效



### 9、谈谈你对sql的优化经验

- 表的设计优化
  - 比如设置合适的数据类型，如果你存储的是年龄这个字段，那么就可以采用无符号的tinyint来存储。
  - 比如设置合适的字符串类型（char和varcher），char定长效率高，varchar可变长度，效率低
- SQL语句优化
  - select语句，尽量指定查询的字段名称，不使用*
  - sql语句要避免索引失效
  - 尽量使用union all代替union，因为union回多一次过滤，效率低
  - 避免在where子句中对字段进行表达式操作
  - join优化，能用inner join就不用left join、right join，如果必须使用，一定要使用小表为主表，不然回造成很多null值。因为inner join会自动对两个表进行优化，优先把小表放在外边
- 主从赋值、读写分离
  - 如果数据库的使用场景中，读的操作比较多的时候，为了避免写的操作所造成的性能影响，可以采用读写分离的架构。

### 10、ACID是什么？

- 原子性（Atomicity）

**原子性**是指一个事务是一个不可分割的最小工作单元。事务中的所有操作，要么都成功，要么都失败回滚到事务开始前的状态。如果任何一个操作失败，那么整个事务都会被撤销。

- 一致性（Consistency）

**一致性**是指事务执行前后，数据库从一个一致性状态转换到另一个一致性状态。这意味着数据库的完整性约束（如主键唯一、外键引用等）在事务开始和结束时都必须保持有效。在上面的转账例子中，一致性保证了总金额在转账前后是不变的。

- 
- 隔离性（Isolation）

**隔离性**是指多个事务并发执行时，一个事务的执行不会被其他事务干扰。这意味着一个事务的中间状态对其他事务是不可见的。数据库系统提供了不同的隔离级别来控制这种可见性，以平衡性能和数据一致性。

- 持久性（Durability）

**持久性**是指一个事务一旦提交，它对数据库的改变就是永久性的，即使系统发生故障（如断电），数据也不会丢失。



### 11、并发事务回带来哪些问题？怎么解决这些问题？MySQL的默认隔离级别是什么？

- 并发事务带来的问题是：脏读、不可重复读、幻读
- Mysql的隔离级别：读未提交（Read uncommitted）、读已提交（Read committed）、可重复读（Repeated read）、串行化 (Serializable)
- MySQL的默认隔离级别是：可重复读（repeated read）
- 解决这些问题可以采用设置MySQL的隔离级别，对于脏读，只要设置成读已条件（Read committed）。对于不可重复读，设置成可重复读（Repeated read）。
- 注意：事务的隔离级别越高，效率越低，因此一般采用Repeated read即可。

### 12、undo log和redo log的区别

- 缓冲池（buffer pool）：主内存中的一个区域，里面可以缓冲磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据，
- 数据页（page）:是innodb存储引擎磁盘管理的最小单元，每个叶的大小是16K。页中存储的是行数据。



## 框架篇

### 1、Spring框架中的单例Bean是线程安全的吗？

Spring框架中的Bean它不是线程安全的。

Spring框架中有一个@Scope注解，默认是singleton，单例的。

因为一般在spring中的bean都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，就需要考虑线程安全问题了，可以使用多例或者加锁来解决。

### 2、什么是AOP，你们的项目中有没有使用到AOP？

AOP成为面向切面编程，用户将哪些与业务无关、但是却多个对象产生影响的公告行为和逻辑，抽取并封装成一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。

常用的AOP使用场景：

- 记录日志
- 缓冲处理
- spring中内置的事务处理
- 统计业务耗时





### 3、Spring中的事务是如何实现的

Spring支持编程式事务管理和声明式事务管理两种方式。

- 编程式事务控制：需使用TransactionTemplate来进行实现，对代码有侵入性，项目中很少使用

- 声明式事务管理：声明式事务管理建立在AOP之上。其本质就是通过AOP功能，对方法的前后进行拦截，将事务的功能编程到拦截的方法中，也就是在目标方法执行前开启一个事务，在方法执行完毕后提交一个事务或者回滚事务。

  

### 4、Spring中事务失效的场景有哪些？

- 异常捕获处理
  - 
- 抛出检测异常
- 非public方法
  - 非public的方法，无法暴露出这个方法的代理对象，而AOP是基于代理实现的，因此无法进行AOP，无法进行AOP，事务当然失效了

