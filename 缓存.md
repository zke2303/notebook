# 缓存

## 认识缓存

### 什么是缓存？

缓存（Cache）是一种存储机制，用于临时存储那些访问频繁、计算代价较高或者速度较慢的数据，以便在下次请求时能够更快速地获取。这种方式通过减少对底层资源（如数据库、文件系统、远程服务器等）的访问，提高系统的响应速度和性能。简单来说，缓存就是一种具备高效读写能力的数据暂存区



## 缓存更新策略

#### 概念

缓存更新策略是指在缓存中的数据过期或被修改时，如何更新缓存的方式。正确的缓存更新策略能够确保缓存中的数据始终保持有效，同时避免缓存不一致、缓存穿透等问题。

#### 三种策略

- 内存淘汰：通过redis自带的内存淘汰机制
- 过期淘汰：利用expire命令设置过期时间
- 主动更新：主动完成数据库与缓存的同时更新



#### 策略的选择

根据不同的需求选择不同的策略，对于**数据一致性高**的需求，采用主动更新，**低一致性**采用内存淘汰或者过期淘汰。



#### 主动更新的方案

- #### 1. **Cache Aside (缓存旁路)**

  在 **Cache Aside** 模式下，缓存是由应用程序控制的，缓存的读取和更新都需要由应用程序来管理。

  - **操作流程**：
    1. **读取缓存**：当应用需要读取某个数据时，首先查询缓存。如果缓存中有数据（缓存命中），则直接返回。如果没有数据（缓存未命中），则从数据库中读取数据，并将数据放入缓存中，以便下次使用。
    2. **更新缓存**：当应用需要更新某个数据时，首先更新数据库，然后再更新缓存。
  - **优点**：
    - **一致性好**：可以确保缓存和数据库中的数据一致，因为每次更新数据库时，都要手动同步缓存。
    - **灵活性强**：缓存的更新完全由应用程序控制，能够灵活地处理不同的业务逻辑。
    - **简单易实现**：相比于其他模式，Cache Aside 模式实现相对简单，不需要额外的中间层。
  - **缺点**：
    - **缓存失效**：在高并发环境下，如果缓存数据失效或被清除，可能会引起大量的数据库查询，导致数据库压力增加。
    - **应用程序复杂性**：需要开发者在每个数据读取和更新时手动处理缓存和数据库的一致性，增加了开发和维护的复杂度。
  - **适用场景**：
    - 适用于数据读取较多，更新较少的场景。
    - 当应用需要更精细地控制缓存时，比如根据具体业务需求决定缓存更新策略。

  #### 2. **Read/Write Through (读写穿透)**

  在 **Read/Write Through** 模式下，缓存和数据库的更新是自动同步的，应用程序不需要直接操作缓存和数据库之间的一致性。

  - **操作流程**：
    1. **读取数据**：当应用需要读取数据时，首先会访问缓存。如果缓存中有数据（缓存命中），则直接返回。如果没有数据（缓存未命中），则从数据库中读取数据并将其写入缓存，最后返回数据。
    2. **写入数据**：当应用更新数据时，数据会先写入缓存，再写入数据库。缓存中的数据在写入数据库后自动更新。
  - **优点**：
    - **一致性保证**：由于缓存和数据库之间的写操作是同步的，因此保持了一致性。
    - **简化开发**：应用程序不需要手动控制缓存更新，缓存和数据库更新的过程由缓存中间层自动完成。
    - **性能提升**：缓存的读取速度非常快，尤其适用于高频读取的场景。
  - **缺点**：
    - **性能瓶颈**：每次写操作都会同时更新数据库和缓存，因此会增加写入操作的延迟，可能会成为性能瓶颈。
    - **缓存的维护成本**：如果数据的更新频率很高，频繁的缓存更新可能导致系统的整体性能下降，尤其是当数据变动很频繁时。
  - **适用场景**：
    - 适用于对一致性要求较高的场景，尤其是写操作比较频繁，或者需要快速读取数据的应用。
    - 常用于数据量不太大的场景，避免频繁的缓存和数据库更新造成负担。

  #### 3. **Write Back (写回)**

  在 **Write Back** 模式下，数据首先更新到缓存中，而不是立即写入数据库。数据库的更新操作会被延迟，并且可能是批量更新。

  - **操作流程**：
    1. **读取数据**：当应用需要读取数据时，首先从缓存中获取。如果缓存中有数据（缓存命中），则直接返回；如果缓存中没有数据（缓存未命中），则从数据库中获取数据，并将其存入缓存中。
    2. **写入数据**：当应用更新数据时，首先将数据写入缓存中，而不是立即写入数据库。写入数据库的操作是异步进行的，并且可以在一定时间后批量执行，或者延迟到后台线程处理。
  - **优点**：
    - **减少数据库负载**：通过延迟写入数据库，减少了数据库的写入操作，特别是对于高频写操作的场景。
    - **性能提升**：对于写操作频繁的场景，Write Back 可以提高系统的性能，因为数据库的写操作被延迟或者批量处理。
    - **适应大流量场景**：适用于写操作频繁且对即时一致性要求不高的场景。
  - **缺点**：
    - **一致性风险**：由于缓存和数据库之间的写操作是异步的，因此可能会导致缓存和数据库的数据不一致。例如，如果系统崩溃或出现故障，缓存中的数据可能没有及时写入数据库。
    - **实现复杂性**：需要管理缓存与数据库之间的延迟写入和一致性，涉及到更多的异步机制和事务管理。
  - **适用场景**：
    - 适用于写频繁但对数据一致性要求不特别严格的场景，例如日志、统计数据等。
    - 在流量高、写入操作频繁的应用中，Write Back 是一个提高性能的有效方式。



#### Cache Aside的模式选择

- 在 **Cache Aside** 模式下，缓存的管理完全由应用程序控制。具体到缓存的更新和删除、操作的先后顺序、以及如何确保数据库和缓存的一致性，以下是一些常见的设计选择和考虑：

  ------

  ### **1. 采用更新缓存还是删除缓存？**

  选择 **更新缓存** 还是 **删除缓存** 取决于具体的应用场景和需求：

  #### **更新缓存**（Write-Through 方式）

  - **适用场景**：当数据更新频繁时，更新缓存是一种常见的选择。每次数据库更新时，立即将数据同步到缓存中，保证缓存中的数据始终是最新的。
  - **优点**：
    - 数据一致性好。每次写操作都同时更新数据库和缓存，避免了缓存与数据库不一致的情况。
    - 适用于数据的读取量远大于更新量的场景，缓存数据的时效性较高。
  - **缺点**：
    - 可能导致缓存的更新频率过高，尤其是在数据变化较频繁的情况下，增加了缓存的维护成本。
    - 如果数据量大，更新缓存可能会带来性能开销。

  #### **删除缓存**（Lazy-Loading 方式）

  - **适用场景**：删除缓存适用于数据更新较少，或者更新的数据对系统性能影响较小的场景。当数据更新时，先删除缓存，在下次查询时从数据库中加载并重新缓存数据。
  - **优点**：
    - **避免缓存污染**：如果数据发生变化不频繁，删除缓存后通过懒加载的方式查询数据库，并更新缓存，确保缓存中的数据是最新的。
    - **减少缓存负担**：不需要每次写操作时都同步更新缓存，适用于频繁更新的大数据集或热点数据较少的场景。
  - **缺点**：
    - **缓存未命中**：删除缓存后，下一次请求会造成缓存未命中的情况，需要查询数据库，导致性能下降。
    - 可能增加数据库的查询压力，特别是在大量删除缓存后，可能频繁查询数据库。

  ------

  ### **2. 先操作数据库还是缓存？**

  在 **Cache Aside** 模式中，通常有两种常见的顺序：**先操作数据库** 或 **先操作缓存**。

  **先操作数据库的安全性更高**

  #### **先操作数据库**

  - **适用场景**：适用于数据变化比较复杂，且需要确保数据库操作的正确性和原子性。通常先更新数据库，再更新缓存。
  - **操作流程**：
    1. 应用先对数据库执行更新操作。
    2. 数据库更新成功后，缓存也进行更新（或者删除缓存，让下次查询重新加载数据）。
  - **优点**：
    - **一致性较好**：由于数据库操作是主操作，缓存只是从属操作，可以确保数据库的修改成功后，缓存再进行同步或删除，避免缓存中的脏数据。
    - **事务控制**：可以通过数据库事务确保数据的一致性，如果数据库操作失败，不更新缓存。
  - **缺点**：
    - **延迟**：缓存操作必须在数据库操作成功后才能进行，可能导致延迟，尤其是当写入数据较慢时。

  #### **先操作缓存**

  - **适用场景**：适用于数据更新频率较低，且希望缓存数据始终是最新的场景。先更新缓存，再执行数据库操作。
  - **操作流程**：
    1. 先将数据更新到缓存中。
    2. 然后异步地更新数据库。
  - **优点**：
    - **提高响应速度**：缓存的更新不需要等待数据库操作，可以提高系统的响应速度。
    - **适用于性能敏感场景**，尤其是读多写少的应用。
  - **缺点**：
    - **一致性问题**：如果缓存更新成功但数据库更新失败，可能导致缓存和数据库不一致。
    - **复杂性增加**：需要确保异步更新数据库时不会丢失数据，可以通过消息队列等异步机制来处理，但这增加了实现的复杂度。

  ------

  ### **3. 如何确保数据库与缓存操作的一致性？**

  确保缓存和数据库的一致性是 **Cache Aside** 模式中非常重要的问题。下面是一些常见的策略来保持一致性：

  #### **a. 事务机制**

  - **保证一致性**：如果数据库和缓存的更新需要严格一致，可以使用分布式事务机制（如 **TCC（Try-Confirm-Cancel）**）或者 **两段提交** 来确保在数据库和缓存都成功更新后再返回响应。
  - **使用场景**：对于高一致性要求的系统，可以通过事务机制保证操作的一致性，但这通常会影响性能，尤其是在分布式系统中，事务管理会比较复杂。

  #### **b. 失败重试机制**

  - **异步更新时的失败处理**：当缓存更新成功，数据库更新失败时，可以设计一个**重试机制**，通过后台任务再次尝试更新数据库。
  - **使用场景**：适用于数据变动频繁、并且希望减少数据库操作延迟的系统。通过消息队列、事件驱动等方式，确保数据最终一致性。

  #### **c. 使用缓存空值（Cache-Aside）**

  - **空值缓存**：当数据更新时，除了更新数据库外，可以将“空值”（如 `null` 或特定标记值）缓存，以防止下一次查询时直接访问数据库，减少缓存穿透。通常缓存空值时，应该设置一个较短的缓存过期时间。
  - **使用场景**：适用于存在大量无效或不存在的数据查询请求的场景，避免每次都查询数据库。

  #### **d. 事务日志与异步更新**

  - **使用日志**：当数据更新时，可以在事务日志中记录变动，然后通过日志异步更新缓存。例如，使用 **消息队列** 或 **事件发布/订阅** 模式，将数据库的变动通知给缓存进行更新。
  - **使用场景**：适用于高并发的分布式系统，通过异步处理来确保数据库与缓存的最终一致性。

  #### **e. 确保数据同步的时效性**

  - **定时刷新/批量更新**：对于高频率更新的缓存，设置定时任务周期性地从数据库拉取数据并更新缓存，避免缓存过期时数据库负担过大。可以通过 **定时任务** 或 **后台批处理** 方式来确保缓存数据的时效性。
  - **使用场景**：适用于数据库更新相对较为缓慢，且数据变化周期较长的场景。

  ------

  ### **总结**

  - **更新缓存还是删除缓存**：
    - 频繁更新的数据，可以选择**更新缓存**，保证缓存数据始终是最新的。
    - 数据不常更新的场景，选择**删除缓存**，通过懒加载的方式查询数据库并更新缓存。
  - **先操作数据库还是缓存**：
    - 先操作数据库保证数据一致性，后操作缓存。
    - 先操作缓存适用于性能敏感的读多写少场景，但需要异步确保数据库更新。
  - **确保一致性**：
    - 使用事务机制、消息队列等异步机制确保数据库和缓存的最终一致性。
    - 在缓存操作时，可以使用失败重试、空值缓存等策略来提高一致性保障。

  通过合理选择这些策略，可以确保 **Cache Aside** 模式中的缓存与数据库操作的一致性，从而提高系统的性能和可靠性。



## 缓存穿透（Cache Penetration）

缓存穿透是指请求的数据不在缓存中，且也不存在于数据库中，但请求依然通过缓存层，直接访问数据库，从而绕过了缓存。这种情况通常会导致不必要的数据库查询，增加数据库的负担，降低系统的性能，特别是在高并发场景下，可能会对数据库造成严重压力。



### **如何解决缓存穿透？**

为了防止缓存穿透，可以采取以下几种常见的方法：

------

#### **1. 布隆过滤器（Bloom Filter）**

布隆过滤器是一种基于哈希算法的数据结构，用来判断一个元素是否在集合中。它的特点是查询速度非常快，并且占用空间小，适合用来防止缓存穿透。

##### **布隆过滤器原理**：

- 布隆过滤器使用多个哈希函数对每个元素进行处理，并将其映射到位数组中的若干位置。对于每个请求的元素，通过哈希函数映射到数组中相应的位置，如果所有对应的位都被设置为 `1`，则认为元素存在；如果某个位置是 `0`，则认为该元素一定不存在。

##### **使用方式**：

- **在缓存前面加一个布隆过滤器**，当请求到来时，首先检查布隆过滤器，若过滤器判断该数据不存在，则直接返回，不再查询缓存和数据库。
- 如果布隆过滤器认为数据存在，才去查询缓存或数据库。

##### **优点**：

- **空间效率高**，对大量数据的查询非常高效。
- 通过在缓存前加上布隆过滤器，可以大大减少数据库的无效查询。

##### **缺点**：

- 布隆过滤器可能会产生**假阳性**，即判断一个元素存在，但实际上该元素并不在集合中。
- 需要适当调优布隆过滤器的大小和哈希函数，控制假阳性率。



#### **2. 缓存空值（Cache Empty）**

缓存空值是指当查询数据库时，如果数据不存在，缓存中存入一个特殊的标记（如 `null` 或某个特定值），用来表示该数据不存在。这样，即使数据不存在，后续相同的请求也会直接命中缓存，而不再查询数据库。

##### **操作流程**：

1. **数据库查询时**，如果查询到数据不存在（如返回 `None` 或空结果），将该空数据缓存起来（缓存空值）。
2. 后续请求时，如果缓存命中空值，直接返回空数据，避免再次查询数据库。

##### **优点**：

- 可以防止恶意请求或无效查询重复访问数据库。
- 对于一些不可用或异常的数据，缓存空值可以有效减少对数据库的压力。

##### **缺点**：

- 如果缓存的空值过期时间设置过长，可能会造成缓存中长期存在无效的数据。
- 空值缓存过期时，仍然可能带来一定的负担。



## **缓存雪崩（Cache Avalanche）**

缓存雪崩是指在缓存系统中，当大量缓存失效或者同时过期时，导致大量请求直接访问数据库，从而给数据库带来巨大的压力，甚至可能导致数据库崩溃。特别是在高并发的场景下，这种情况会迅速放大，给整个系统的稳定性带来严重威胁。

### **如何解决缓存雪崩问题？**

为了防止缓存雪崩的发生，通常会采取以下几种策略：

------

#### **1. 设置不同的过期时间（Cache Randomization）**

设置缓存的过期时间时，可以将每个缓存项的过期时间设置为不同的值，避免大量缓存同时过期。

##### **策略**：

- **随机过期时间**：对于每个缓存项，可以设置一个随机的过期时间。比如，缓存的过期时间可以在某个范围内随机变化（如设置在 30 分钟到 90 分钟之间），这样可以避免大量缓存同时过期。

##### **优点**：

- 通过打乱过期时间，避免在同一时间大量缓存同时失效，减轻数据库压力。

##### **缺点**：

- 缓存数据的过期时间不固定，可能需要额外的管理逻辑。

#### 

#### **2. 缓存预热（Cache Preload / Cache Warming）**

缓存预热是在系统启动时或者系统负载较低时，提前将一些常用的数据加载到缓存中。这样，即使某些缓存失效，系统也能通过预热数据避免突然访问数据库。

##### **策略**：

- 在缓存失效之前，提前加载一些常用的数据（例如：热点数据、频繁访问的数据）到缓存中。
- 可以通过定时任务来定期预热缓存，确保缓存中始终有常用的数据。

##### **优点**：

- 减少了缓存失效时对数据库的压力，确保在高并发的情况下，系统可以更平稳地运行。

##### **缺点**：

- 需要额外的预热过程，且可能会占用一定的内存。



## 缓存击穿(Cache Breakdown）

缓存击穿是指缓存中原本应该存在的数据由于某些原因（如缓存过期、被清除等）失效，而此时大量请求仍然会直接访问数据库，导致数据库的压力急剧增加。**缓存击穿通常发生在某个热门数据的缓存失效时**，多个并发请求同时访问数据库，给数据库带来较大负担。

**典型场景：**

- 某个热点数据的缓存失效，导致大量请求同时访问数据库。这个数据并没有被其他请求提前加载到缓存中，最终所有的请求都要查询数据库，造成数据库压力骤增。

**举个例子：**

假设某个用户信息缓存过期了，并且系统中有大量并发请求需要访问该用户信息。如果没有合适的机制控制，这些请求可能会同时访问数据库，导致数据库查询过于频繁，最终导致数据库崩溃。



### **如何解决缓存击穿问题？**

为了防止缓存击穿的发生，可以采取以下几种常见的解决策略：

------

### **1. 使用互斥锁（Mutex Locking）**

当缓存中某个数据失效时，可以使用互斥锁来确保只有一个请求会访问数据库，其他请求则等待缓存更新，避免多个并发请求同时查询数据库。

在redis中，可以通过string类型中的SETNX来实现互斥锁，当未命中缓存时，这时需要去查询数据库去重构缓存，这时需要一个线性去完成查询数据库去重构缓存，需要锁定这个数据访问，这时可用通过SETNX来实现，当一个线程使用SETNX创建缓存时，其他的线性就无法创建这个缓存，就保障了互斥。解锁时，直接删除这个缓存即可。

#### **策略**：

- 在缓存失效时，使用锁机制（如 Redis 提供的分布式锁）来保证在同一时间，只有一个请求会去查询数据库。
- 其他请求则阻塞或者等待，直到数据库返回结果并将数据加载到缓存中。

#### **优点**：

- 可以有效避免并发请求同时访问数据库，减少数据库的压力。
- 保证数据一致性，避免缓存和数据库的不同步。

#### **缺点**：

- 可能会引起请求的等待，增加系统的响应延迟。
- 锁的粒度过大可能会导致性能瓶颈，需要合理设计锁的使用。



### 2.逻辑过期

**逻辑过期**是指缓存中的数据在缓存层面上没有实际的过期时间，而是由应用程序内部的逻辑来控制数据的有效性。数据的过期和更新不依赖于缓存的实际过期时间，而是通过应用程序的控制来决定何时重新加载数据。

#### **策略**：

1. **数据缓存时设置虚拟过期时间**：当缓存某个数据时，设置一个虚拟的过期时间（而不是真实的过期时间），表示该数据的有效期。这个时间可以是业务逻辑上认为该数据需要重新加载的时刻。
2. **请求访问缓存时，检查虚拟过期时间**：每次请求访问缓存时，如果缓存的数据已经超过虚拟的过期时间，缓存不会立刻失效，而是允许一个请求去重新加载数据库并更新缓存。其他的请求会等待直到缓存更新完毕，而不再同时访问数据库。
3. **通过双重检查保证一致性**：当缓存的数据超过虚拟过期时间时，需要进行数据更新。使用双重检查的机制，确保只有第一个请求去访问数据库，其他请求等待更新。

#### **如何实现逻辑过期：**

- 设定一个虚拟过期时间（比如，缓存的数据有效期为30分钟），但是缓存本身并不真正过期。
- 每次请求时，判断缓存数据是否过期，如果过期，触发数据库查询并更新缓存。
- **控制更新过程**：在缓存过期的那一时刻，可以通过锁机制或限流机制，保证只有一个请求去查询数据库，其他请求等待。

#### **优点：**

- **减少数据库压力**：逻辑过期的实现避免了缓存失效时大量请求直接查询数据库，减少了数据库的压力。
- **提高性能**：避免了缓存每次都过期并重新加载数据的开销，保证了高频数据的缓存命中。
- **较高的灵活性**：可以根据业务需求灵活调整缓存的过期策略，而不完全依赖于缓存系统的过期机制。

#### **缺点：**

- **需要额外的逻辑管理**：需要管理每个缓存数据的虚拟过期时间以及如何更新缓存，增加了代码复杂度。
- **可能的延迟**：虽然其他请求不会同时查询数据库，但当数据过期时，第一个请求会有一定的延迟来访问数据库。